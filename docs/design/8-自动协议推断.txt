下面这一份我们就聚焦在你点名的主题上：  
**第八份：自动协议推断（auto protocol detection），但保持实用、不乱抽象。**

核心前提还是不变的：  
- manifest-first 是主路径  
- 自动推断只是“糖”，不是“唯一真相”  
- 不能引入 provider 耦合  
- 不能让 runtime 逻辑变得诡异和难以维护  

---

### 一、为什么要做“自动协议推断”，但不能过度依赖？

自动协议推断的实际价值：

- 降低 manifest 编写成本：很多情况下“你其实知道是 SSE / JSON chunk”，但编写者可能懒得写。
- 兼容历史 / 低质量 manifest：比如别人写的 manifest 里没填 protocol。
- 让 runtime 在“信息不完整”时有一个合理的默认行为。

但不能依赖它的原因：

- 推断永远有误判风险，尤其是边缘 provider 或自建服务。
- 推断逻辑本质上是“启发式”，不是协议的一部分。
- manifest-first 的哲学仍然是：**显式优先于隐式**。

所以设计目标是：

> **有 protocol 字段→严格按 manifest 来；  
> 没有 protocol 字段→启用“保守、可控、可关闭”的自动推断。**

---

### 二、总思路：显式优先 + 保守推断 + 可配置

设计成三个层级：

1. **显式声明优先：**  
   - 如果 `endpoint.protocol` 存在 → 直接使用，不做推断。
2. **保守推断：**  
   - 如果 `endpoint.protocol` 为空 → 用一套简单、安全的 heuristics 推断。
3. **可配置策略：**  
   - 允许用户在 runtime config 中选择：
     - 关闭自动推断（强制要求 manifest 写 protocol）
     - 开启推断但只在某些 provider/base_url 上允许
     - 开启推断且记录 warning 日志

---

### 三、在代码层面：`ProtocolResolver`

在 runtime 里加一个小组件，而不是到处写 if/else：

```rust
pub enum Protocol {
    Sse,
    JsonChunk,
    Text,
}

pub struct ProtocolResolver {
    pub auto_detect_enabled: bool,
}

impl ProtocolResolver {
    pub fn resolve(
        &self,
        endpoint_protocol: Option<&str>,
        url: &str,
        headers: &std::collections::HashMap<String, String>,
    ) -> Result<Protocol, String> {
        // 1. manifest 显式优先
        if let Some(p) = endpoint_protocol {
            return Self::from_str(p);
        }

        // 2. 自动推断关掉时，直接报错
        if !self.auto_detect_enabled {
            return Err("protocol missing and auto-detect disabled".into());
        }

        // 3. 自动推断
        self.detect(url, headers)
    }

    fn from_str(p: &str) -> Result<Protocol, String> {
        match p {
            "sse" => Ok(Protocol::Sse),
            "json_chunk" => Ok(Protocol::JsonChunk),
            "text" => Ok(Protocol::Text),
            _ => Err(format!("unknown protocol: {}", p)),
        }
    }
}
```

---

### 四、自动推断 `detect()` 的实际策略（保持简单）

我们只做非常朴素、易理解、风险可控的 heuristics。

```rust
impl ProtocolResolver {
    fn detect(
        &self,
        url: &str,
        headers: &std::collections::HashMap<String, String>,
    ) -> Result<Protocol, String> {
        // 1. 看响应头（典型：SSE）
        if let Some(ct) = headers.get("Content-Type") {
            if ct.contains("text/event-stream") {
                return Ok(Protocol::Sse);
            }
            if ct.contains("application/json") {
                // 这里没法精确区分 "full json" vs "json per chunk"
                // 可以默认 json_chunk，然后在 parser 中处理 "非流式" 的情况
                return Ok(Protocol::JsonChunk);
            }
            if ct.starts_with("text/") {
                return Ok(Protocol::Text);
            }
        }

        // 2. 看 URL pattern（非常保守）
        if url.contains("chat/completions") {
            // 绝大多数 LLM 提供商用 SSE 做流式
            return Ok(Protocol::Sse);
        }

        if url.contains("generate") {
            // Ollama/本地服务很多用 json chunk
            return Ok(Protocol::JsonChunk);
        }

        // 3. 默认回退：text
        Ok(Protocol::Text)
    }
}
```

几个要点：

- 这是一个“best-effort fallback”，不是正式协议的一部分。
- 你可以在日志中打印警告，提醒“使用了 auto detect”。
- 如果你不喜欢基于 URL 推断，可以删掉那部分，仅依赖 `Content-Type`。

---

### 五、在 runtime 中插入 ProtocolResolver 的位置

在 `Runtime.call()` 中，OperatorPlanner 得到的是 `endpoint.protocol: Option<String>`。  
然后：

```rust
let endpoint = plan.endpoint;
let resp = self.executor.execute(...).await?;

// 注意：这里的 headers 是响应头
let headers_map = resp
    .headers()
    .iter()
    .map(|(k, v)| {
        (
            k.to_string(),
            v.to_str().unwrap_or_default().to_string(),
        )
    })
    .collect::<std::collections::HashMap<_, _>>();

let protocol = self.protocol_resolver
    .resolve(
        endpoint.protocol.as_deref(),
        resp.url().as_str(),
        &headers_map,
    )
    .map_err(|msg| ModelError::internal(format!("protocol resolve error: {}", msg)))?;
```

然后再走：

```rust
let raw_stream = Box::pin(resp.bytes_stream());

let parser_name = match protocol {
    Protocol::Sse => "sse",
    Protocol::JsonChunk => "json_chunk",
    Protocol::Text => "text",
};

let parser_fn = self.parsers.get(parser_name)
    .ok_or_else(|| ModelError::internal(format!("parser {} not found", parser_name)))?;

let model_stream = parser_fn(raw_stream);
Ok(model_stream)
```

---

### 六、和 manifest-first 的关系：谁是主，谁是辅？

我们可以明确一个原则（你应该会认同）：

1. **manifest 是主**：  
   - 一旦写了 `protocol` 字段，runtime 绝不“帮你聪明”。
   - 如果 `protocol` 是错的，那是 manifest 的问题，而不是 runtime 的。

2. **自动推断是辅**：  
   - 仅在 `protocol` 缺失时启用。  
   - 可以通过 runtime config 关闭。  
   - 启用时最好记录一个 warning log。

你甚至可以在开发/测试模式下：

- 开启“强校验模式”：  
  - 如果是 auto-detect，则提示“请显式写明 protocol”。

---

### 七、关于“未来会不会出现意外协议”的再回答（结合 auto-detect）

自动推断逻辑本身并不要求你知道所有协议，它只做：

- 常见情况：SSE / JSON / text  
- 启发式 fallback：不认识就当 text 或报错  

若未来出现新的协议，比如：

- `application/x-ndjson`  
- 自定义的 chunk framing  
- WebSocket 带自定义子协议  

你会：

1. 新增一个 parser  
2. 在 ParserRegistry 注册它  
3. 在 manifest 中显式写 `protocol: xxx`  

而不是指望 auto-detect magical work。

auto-detect 是“人性化”、“容错”，不是“能力面”。

---

### 八、现在阶段：我建议你实际落地的程度

结合你现在的目标和阶段，我给你一个落地的建议版本：

1. **实现 ProtocolResolver，但只做非常简短的逻辑：**
   - 有 `protocol` 字段 → 直接用  
   - 没有 → 默认用 `sse` 或 `json_chunk`，并打印 warning  

2. **先别做复杂 heuristics：**
   - 不用 URL 规则  
   - 不用 Content-Type 推断  
   - 保持逻辑可预测、可控、容易删除  

3. **等你真的接入多个 provider / 服务时：**
   - 看看实际遇到的情况  
   - 再决定要不要加一两条简单 heuristics  

这符合你之前强调的：

> “有没有必要抽象到那么深的程度，现阶段是不是用得上？”

——不用现在一上来就搞一套看起来很聪明、实际 debug 很难的推断系统。

---
