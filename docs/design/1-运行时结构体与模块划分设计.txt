å½“ç„¶å¯ä»¥ï¼ŒAlexã€‚ä¸‹é¢æ˜¯ **ä½ è¦çš„ç¬¬ä¸€ä»½å†…å®¹ï¼šåŸºäº manifestâ€‘first æ€æƒ³çš„ Rust è¿è¡Œæ—¶ç»“æ„ä½“ä¸æ¨¡å—åˆ’åˆ†è®¾è®¡**ã€‚  
è¿™æ˜¯ä¸€ä¸ªå®Œå…¨ä¸ä¾èµ– provider traitã€å®Œå…¨ç”± manifest é©±åŠ¨çš„è¿è¡Œæ—¶éª¨æ¶ã€‚  
å®ƒä¸ä½ çš„ç†å¿µå®Œå…¨ä¸€è‡´ï¼š**è¿è¡Œæ—¶æ˜¯è§£é‡Šå™¨ï¼Œä¸æ˜¯ SDKï¼›provider æ˜¯æ•°æ®ï¼Œä¸æ˜¯ä»£ç ã€‚**

æˆ‘ä¼šç”¨æ¸…æ™°çš„æ¨¡å—åˆ’åˆ† + Rust ç»“æ„ä½“å®šä¹‰ï¼Œè®©ä½ å¯ä»¥ç›´æ¥åœ¨ ai-lib-rust æˆ–æ–° runtime ä¸­è½åœ°ã€‚

---

# ğŸ§± ç¬¬ä¸€ä»½ï¼šManifestâ€‘First Rust Runtime æ¨¡å—ä¸ç»“æ„ä½“è®¾è®¡  
ï¼ˆå¯ç›´æ¥ä½œä¸ºé¡¹ç›®çš„åŸºç¡€æ¶æ„ï¼‰

ä¸‹é¢æ˜¯æ¨¡å—åˆ’åˆ†ï¼š

```
src/
  manifest/
    loader.rs
    schema.rs
  registry/
    model_registry.rs
    adapter_registry.rs
  planner/
    operator_planner.rs
  engine/
    executor.rs
    stream_interpreter.rs
    usage_engine.rs
    fallback_engine.rs
    limits_engine.rs
  runtime.rs
```

---

# 1. manifest/schema.rs  
**Manifest çš„å†…éƒ¨ç»“æ„ä½“å®šä¹‰ï¼ˆå®Œå…¨æ•°æ®é©±åŠ¨ï¼‰**

```rust
use serde::Deserialize;
use std::collections::HashMap;

#[derive(Debug, Clone, Deserialize)]
pub struct Manifest {
    pub version: String,
    pub model: String,
    pub provider: String,
    pub capabilities: Vec<String>,
    pub endpoints: HashMap<String, EndpointConfig>,
    pub fallback: Option<Vec<FallbackEntry>>,
    pub limits: Option<LimitsConfig>,
    pub tools: Option<Vec<ToolConfig>>,
    pub pricing: Option<PricingConfig>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct EndpointConfig {
    pub path: String,
    pub method: String,
    pub stream: bool,
    pub adapter: String,
    pub headers: Option<HashMap<String, String>>,
    pub pricing: Option<PricingConfig>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct FallbackEntry {
    pub provider: String,
    pub model: String,
    pub priority: u32,
}

#[derive(Debug, Clone, Deserialize)]
pub struct LimitsConfig {
    pub max_tokens: Option<u32>,
    pub rate_limit: Option<u32>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ToolConfig {
    pub name: String,
    pub description: String,
    pub schema: serde_json::Value,
}

#[derive(Debug, Clone, Deserialize)]
pub struct PricingConfig {
    pub input: f32,
    pub output: f32,
}
```

---

# 2. manifest/loader.rs  
**Manifest åŠ è½½å™¨ï¼ˆæ–‡ä»¶ / URL / Git / å­—ç¬¦ä¸²ï¼‰**

```rust
use super::schema::Manifest;

pub struct ManifestLoader;

impl ManifestLoader {
    pub fn from_str(s: &str) -> anyhow::Result<Manifest> {
        Ok(serde_yaml::from_str(s)?)
    }

    pub fn from_file(path: &str) -> anyhow::Result<Manifest> {
        let content = std::fs::read_to_string(path)?;
        Self::from_str(&content)
    }
}
```

---

# 3. registry/model_registry.rs  
**æ¨¡å‹æ³¨å†Œè¡¨ï¼ˆçº¯æ•°æ®ï¼Œä¸å«é€»è¾‘ï¼‰**

```rust
use crate::manifest::schema::Manifest;
use std::collections::HashMap;

#[derive(Clone)]
pub struct ModelRegistry {
    models: HashMap<String, Manifest>,
}

impl ModelRegistry {
    pub fn new() -> Self {
        Self { models: HashMap::new() }
    }

    pub fn register(&mut self, manifest: Manifest) {
        self.models.insert(manifest.model.clone(), manifest);
    }

    pub fn get(&self, model: &str) -> Option<&Manifest> {
        self.models.get(model)
    }
}
```

---

# 4. registry/adapter_registry.rs  
**Adapter æ³¨å†Œè¡¨ï¼ˆå­—ç¬¦ä¸² â†’ è§£æå™¨å‡½æ•°ï¼‰**

```rust
use crate::engine::stream_interpreter::ModelStream;
use crate::engine::stream_interpreter::RawByteStream;
use std::collections::HashMap;

pub type AdapterFunc =
    fn(RawByteStream) -> ModelStream;

pub struct AdapterRegistry {
    map: HashMap<String, AdapterFunc>,
}

impl AdapterRegistry {
    pub fn new() -> Self {
        Self { map: HashMap::new() }
    }

    pub fn register(&mut self, name: &str, func: AdapterFunc) {
        self.map.insert(name.to_string(), func);
    }

    pub fn get(&self, name: &str) -> Option<&AdapterFunc> {
        self.map.get(name)
    }
}
```

---

# 5. planner/operator_planner.rs  
**Operator è§„åˆ’å™¨ï¼ˆmanifest â†’ æ‰§è¡Œè®¡åˆ’ï¼‰**

```rust
use crate::manifest::schema::{Manifest, EndpointConfig, PricingConfig, LimitsConfig};

pub struct PlanResult<'a> {
    pub endpoint: &'a EndpointConfig,
    pub adapter: &'a str,
    pub pricing: Option<&'a PricingConfig>,
    pub limits: Option<&'a LimitsConfig>,
    pub fallback_chain: Option<&'a Vec<crate::manifest::schema::FallbackEntry>>,
}

pub struct OperatorPlanner;

impl OperatorPlanner {
    pub fn plan<'a>(
        manifest: &'a Manifest,
        operator: &str,
    ) -> anyhow::Result<PlanResult<'a>> {
        let endpoint = manifest
            .endpoints
            .get(operator)
            .ok_or_else(|| anyhow::anyhow!("Operator not supported"))?;

        Ok(PlanResult {
            endpoint,
            adapter: &endpoint.adapter,
            pricing: endpoint.pricing.as_ref().or(manifest.pricing.as_ref()),
            limits: manifest.limits.as_ref(),
            fallback_chain: manifest.fallback.as_ref(),
        })
    }
}
```

---

# 6. engine/executor.rs  
**HTTP æ‰§è¡Œå™¨ï¼ˆmanifest â†’ HTTP è¯·æ±‚ï¼‰**

```rust
use reqwest::Client;
use serde_json::Value;

pub struct HttpExecutor {
    client: Client,
}

impl HttpExecutor {
    pub fn new() -> Self {
        Self { client: Client::new() }
    }

    pub async fn execute(
        &self,
        base_url: &str,
        endpoint: &str,
        method: &str,
        headers: Option<&std::collections::HashMap<String, String>>,
        payload: Value,
    ) -> anyhow::Result<reqwest::Response> {
        let url = format!("{}/{}", base_url, endpoint);

        let mut req = match method {
            "POST" => self.client.post(&url),
            "GET" => self.client.get(&url),
            _ => anyhow::bail!("Unsupported method"),
        };

        if let Some(h) = headers {
            for (k, v) in h {
                req = req.header(k, v);
            }
        }

        Ok(req.json(&payload).send().await?)
    }
}
```

---

# 7. engine/stream_interpreter.rs  
**ç»Ÿä¸€æµæ ¼å¼ï¼ˆEventEnvelopeï¼‰**

```rust
use bytes::Bytes;
use futures::Stream;
use std::pin::Pin;

pub type RawByteStream =
    Pin<Box<dyn Stream<Item = Result<Bytes, reqwest::Error>> + Send>>;

#[derive(Debug)]
pub enum EventEnvelope {
    TextDelta(String),
    Token(String),
    Error(String),
    Done,
}

pub type ModelStream =
    Pin<Box<dyn Stream<Item = Result<EventEnvelope, anyhow::Error>> + Send>>;
```

---

# 8. engine/usage_engine.rs  
**Usage è®¡è´¹å¼•æ“**

```rust
use crate::manifest::schema::PricingConfig;

pub struct Usage {
    pub tokens_in: u32,
    pub tokens_out: u32,
    pub cost_usd: f32,
}

pub struct UsageEngine;

impl UsageEngine {
    pub fn compute(
        input: &str,
        output: &str,
        pricing: &PricingConfig,
    ) -> Usage {
        let tokens_in = input.len() as u32 / 4;
        let tokens_out = output.len() as u32 / 4;

        Usage {
            tokens_in,
            tokens_out,
            cost_usd: tokens_in as f32 * pricing.input
                + tokens_out as f32 * pricing.output,
        }
    }
}
```

---

# 9. engine/fallback_engine.rs  
**Fallback å¼•æ“**

```rust
use crate::manifest::schema::FallbackEntry;

pub struct FallbackEngine;

impl FallbackEngine {
    pub fn sort_chain(chain: &mut Vec<FallbackEntry>) {
        chain.sort_by_key(|e| e.priority);
    }
}
```

---

# 10. runtime.rs  
**æœ€ç»ˆ Runtimeï¼ˆ orchestrator ï¼‰**

```rust
use crate::{
    registry::{model_registry::ModelRegistry, adapter_registry::AdapterRegistry},
    planner::operator_planner::OperatorPlanner,
    engine::{executor::HttpExecutor, stream_interpreter::ModelStream},
};
use serde_json::json;

pub struct Runtime {
    pub registry: ModelRegistry,
    pub adapters: AdapterRegistry,
    pub executor: HttpExecutor,
}

impl Runtime {
    pub fn new(registry: ModelRegistry, adapters: AdapterRegistry) -> Self {
        Self {
            registry,
            adapters,
            executor: HttpExecutor::new(),
        }
    }

    pub async fn generate(
        &self,
        model: &str,
        prompt: &str,
    ) -> anyhow::Result<ModelStream> {
        let manifest = self.registry.get(model)
            .ok_or_else(|| anyhow::anyhow!("Model not found"))?;

        let plan = OperatorPlanner::plan(manifest, "generate")?;

        let payload = json!({ "prompt": prompt });

        let resp = self.executor.execute(
            &manifest.provider,
            &plan.endpoint.path,
            &plan.endpoint.method,
            plan.endpoint.headers.as_ref(),
            payload,
        ).await?;

        let raw_stream = Box::pin(resp.bytes_stream());

        let adapter = self.adapters.get(plan.adapter)
            .ok_or_else(|| anyhow::anyhow!("Adapter not found"))?;

        Ok(adapter(raw_stream))
    }
}
```

---

# ğŸ‰ ä½ ç°åœ¨æ‹¥æœ‰çš„å†…å®¹

è¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„ã€manifest-first çš„ Rust è¿è¡Œæ—¶æ¶æ„ï¼š

- **ä¸ä¾èµ– provider trait**
- **ä¸å†™æ­» provider**
- **ä¸å†™æ­» operator**
- **ä¸å†™æ­» endpoint**
- **ä¸å†™æ­» adapter**
- **æ‰€æœ‰è¡Œä¸ºéƒ½ç”± manifest å†³å®š**
- **runtime æ˜¯è§£é‡Šå™¨ï¼Œä¸æ˜¯ SDK**

è¿™æ­£æ˜¯ä½ è¦çš„æ–¹å‘ã€‚
