下面这一份，我们把你刚强调的点落实到底：**错误在全局统一化，作为 runtime 和应用层之间的“协议”**，为上层 fallback / 策略引擎提供可靠基础。

---

### 目标与原则

- **错误模型是全局统一的**：不因 provider / adapter / HTTP 库不同而变化。
- **错误来源被抽象成统一结构**：HTTP、网络、限额、本地逻辑、解析错误都映射到同一套枚举。
- **错误只在 runtime 一层收敛一次**：应用层看到的始终是统一的 `ModelError`。
- **错误携带足够信息供策略决策**：可区分是否可重试、是否适合 fallback、是否业务侧应立即失败。

---

## 一、全局统一错误模型设计

### 1.1 顶层错误类型：`ModelError`

```rust
#[derive(Debug)]
pub struct ModelError {
    pub kind: ErrorKind,
    pub code: Option<String>,      // provider / http / internal code
    pub message: String,          // 人类可读描述
    pub source: Option<anyhow::Error>, // 保留底层 error（调试用）
}
```

- **kind**：统一分类（应用层主要依赖这个决策）。
- **code**：可选细粒度信息，如 HTTP 状态码、provider 自定义 error code。
- **message**：日志/调试信息。
- **source**：保留原始错误，方便调试，但上层策略不依赖它。

### 1.2 错误分类枚举：`ErrorKind`

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ErrorKind {
    // 输入/调用层面
    InvalidRequest,    // 参数错误、schema 不符、必填字段缺失
    LimitExceeded,     // 本地 max_tokens / rate limit 限制

    // 远端/网络层面
    Network,           // DNS、连接失败、超时等
    ProviderUnavailable, // 远端 5xx 或「服务不可用」
    RateLimited,       // 429 等

    // 数据/协议层
    ProtocolError,     // provider 返回格式与 adapter 预期不符
    ParseError,        // JSON/SSE 解析失败

    // 内部/未知
    Internal,          // runtime bug 等
    Unknown,           // 无法分类的异常
}
```

### 1.3 统一的“重试/回退”语义

错误类型要直接支撑策略决策，可以给 `ErrorKind` 加一些 helper 方法：

```rust
impl ErrorKind {
    pub fn is_retryable(&self) -> bool {
        matches!(
            self,
            ErrorKind::Network
                | ErrorKind::ProviderUnavailable
                | ErrorKind::RateLimited
        )
    }

    pub fn is_client_bug(&self) -> bool {
        matches!(self, ErrorKind::InvalidRequest | ErrorKind::LimitExceeded)
    }

    pub fn is_server_side(&self) -> bool {
        matches!(
            self,
            ErrorKind::ProviderUnavailable
                | ErrorKind::RateLimited
                | ErrorKind::ProtocolError
        )
    }
}
```

应用层可以直接用这些方法来做策略，而不用关心 provider 细节。

---

## 二、错误收敛点：在哪一层统一？

你的要求是“全局统一化”，实际就是：**所有错误必须在 runtime 里只收敛一次**。

可以明确几个“收敛点”：

1. **HttpExecutor 层**：收敛网络/HTTP错误。
2. **Adapter / Stream 解析层**：收敛协议/解析错误。
3. **LimitsEngine 层**：收敛本地限额错误。
4. **Runtime API 出口**：保证对外只丢出 `ModelError`。

### 2.1 HttpExecutor 层错误映射

```rust
impl HttpExecutor {
    pub async fn execute(... ) -> Result<reqwest::Response, ModelError> {
        let res = self.client
            .post(&url)
            .json(&payload)
            .send()
            .await
            .map_err(|e| ModelError::from_reqwest_error(e))?;

        if !res.status().is_success() {
            let status = res.status().as_u16();
            let body = res.text().await.unwrap_or_default();
            return Err(ModelError::from_http_status(status, body));
        }

        Ok(res)
    }
}
```

配套构造函数：

```rust
impl ModelError {
    pub fn from_reqwest_error(e: reqwest::Error) -> Self {
        let kind = if e.is_timeout() || e.is_connect() {
            ErrorKind::Network
        } else {
            ErrorKind::Unknown
        };

        ModelError {
            kind,
            code: None,
            message: e.to_string(),
            source: Some(e.into()),
        }
    }

    pub fn from_http_status(status: u16, body: String) -> Self {
        let kind = match status {
            400..=499 => {
                if status == 429 {
                    ErrorKind::RateLimited
                } else {
                    ErrorKind::InvalidRequest
                }
            }
            500..=599 => ErrorKind::ProviderUnavailable,
            _ => ErrorKind::Unknown,
        };

        ModelError {
            kind,
            code: Some(format!("HTTP_{}", status)),
            message: body,
            source: None,
        }
    }
}
```

### 2.2 Adapter / Stream 层错误映射

在 adapter 中，所有解析失败等必须转换成 `ModelError`：

```rust
pub fn openai_adapter(raw: RawByteStream) -> ModelStream {
    Box::pin(raw.map(|chunk_res| {
        let chunk = chunk_res.map_err(|e| ModelError {
            kind: ErrorKind::Network,
            code: None,
            message: e.to_string(),
            source: Some(e.into()),
        })?;

        let text = String::from_utf8(chunk.to_vec()).map_err(|e| ModelError {
            kind: ErrorKind::ParseError,
            code: None,
            message: e.to_string(),
            source: Some(e.into()),
        })?;

        // 正常解析逻辑...
        // 解析 JSON 失败也映射到 ParseError / ProtocolError
        Ok(EventEnvelope::TextDelta(text))
    }))
}
```

这里的关键是：**所有 adapter 都必须遵守统一的错误输出类型 `ModelError`**，不能直接 `anyhow::Error` 或自定义 error 派系。

### 2.3 LimitsEngine 层错误映射

```rust
pub fn check_limits(input_tokens: u32, limits: &LimitsConfig) -> Result<(), ModelError> {
    if let Some(max) = limits.max_tokens {
        if input_tokens > max {
            return Err(ModelError {
                kind: ErrorKind::LimitExceeded,
                code: Some("MAX_TOKENS".into()),
                message: format!("input tokens {} exceed max {}", input_tokens, max),
                source: None,
            });
        }
    }
    Ok(())
}
```

---

## 三、Runtime API 出口：只暴露 `Result<_, ModelError>`

这一点是“全局统一化”的关键：**对应用层暴露的所有 runtime 调用 API，都必须以 `ModelError` 作为唯一错误类型**。

```rust
impl Runtime {
    pub async fn call(
        &self,
        model: &str,
        operator: &str,
        input: &str,
    ) -> Result<ModelStream, ModelError> {
        let manifest = self.registry.get(model)
            .ok_or(ModelError {
                kind: ErrorKind::InvalidRequest,
                code: Some("MODEL_NOT_FOUND".into()),
                message: format!("model {} not found", model),
                source: None,
            })?;

        let plan = OperatorPlanner::plan(manifest, operator)
            .map_err(|e| ModelError {
                kind: ErrorKind::InvalidRequest,
                code: Some("OPERATOR_NOT_SUPPORTED".into()),
                message: e.to_string(),
                source: Some(e),
            })?;

        // 限额检查
        if let Some(limits) = plan.limits {
            let input_tokens = self.tokenizer.count(input);
            check_limits(input_tokens, limits)?;
        }

        // HTTP 调用
        let resp = self.executor
            .execute(&manifest.provider, &plan.endpoint.path, &plan.endpoint.method, plan.endpoint.headers.as_ref(), payload)
            .await?;

        // 流式或非流式
        let raw_stream = Box::pin(resp.bytes_stream());

        let adapter_fn = self.adapters.get(plan.adapter)
            .ok_or(ModelError {
                kind: ErrorKind::Internal,
                code: Some("ADAPTER_NOT_FOUND".into()),
                message: format!("adapter {} not found", plan.adapter),
                source: None,
            })?;

        Ok(adapter_fn(raw_stream))
    }
}
```

这里你可以看到：

- 所有 `.await?` / `?` 抛出的错误，最终都被包进 `ModelError`。
- runtime 对外的错误面只剩下一个统一类型，满足“全局统一化”。

---

## 四、应用层如何利用统一错误做策略（含 fallback）

有了统一错误模型，应用层可以写非常干净的策略逻辑：

```rust
async fn call_with_fallback(
    runtime: &Runtime,
    models: &[&str],
    operator: &str,
    input: &str,
) -> Result<ModelStream, ModelError> {
    let mut last_err: Option<ModelError> = None;

    for &model in models {
        match runtime.call(model, operator, input).await {
            Ok(stream) => return Ok(stream),
            Err(err) => {
                // 记录日志
                tracing::warn!(
                    model = model,
                    kind = ?err.kind,
                    code = ?err.code,
                    "model call failed"
                );

                // 如果是客户端错误，直接返回，不再尝试其他模型
                if err.kind.is_client_bug() {
                    return Err(err);
                }

                // 如果是可重试错误，但我们采用“换模型而非重试”的策略
                if err.kind.is_retryable() {
                    last_err = Some(err);
                    continue;
                }

                // 对于其他错误，记录之后继续尝试下一个
                last_err = Some(err);
            }
        }
    }

    Err(last_err.unwrap_or(ModelError {
        kind: ErrorKind::Unknown,
        code: Some("NO_MODEL_SUCCEEDED".into()),
        message: "no model succeeded".into(),
        source: None,
    }))
}
```

关键点：

- 应用层只依赖 `ErrorKind` 这些统一分类，完全不关心 provider。
- 你可以根据 `is_retryable()` / `is_client_bug()` 做非常自然的策略控制。
- fallback 策略可以越来越高级，而 runtime/manifest 无需变更。

---

## 五、全局统一的含义：从底层到顶层只有一套 error 语义

你强调“全局统一化”，在这个设计里体现为：

- **底层 HTTP/network**：全部映射到 `ErrorKind::Network / ProviderUnavailable / RateLimited`。
- **protocol/adapter 层**：全部映射到 `ErrorKind::ProtocolError / ParseError`。
- **limits 层**：全部映射到 `ErrorKind::LimitExceeded`。
- **调用/配置错误**：全部映射到 `ErrorKind::InvalidRequest`。
- **内部 bug / 未分类异常**：全部映射到 `ErrorKind::Internal / Unknown`。
- **对外 API**：一律 `Result<T, ModelError>`，不暴露任何其他 error 类型。

从 runtime 的角度看：**错误维度只有一套语义，整个系统所有调用逻辑、日志、metrics、应用策略，全部基于这一套。**

这就是你说的那个“全局统一化”，并且是 manifest-first、provider 无关、策略解耦的。

---
