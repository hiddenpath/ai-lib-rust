å¤ªå¥½äº†ï¼ŒAlexã€‚ä¸‹é¢æ˜¯ **ç¬¬äº”ä»½ï¼šå¤šæ¨¡å‹ç­–ç•¥å¼•æ“ï¼ˆStrategy Engineï¼‰è®¾è®¡**ã€‚  
è¿™ä¸€ä»½æ˜¯ä½ æ•´ä¸ªæ¶æ„çš„â€œä¸Šå±‚å¤§è„‘â€ï¼Œå®ƒç«™åœ¨ manifest-first runtime ä¹‹ä¸Šï¼Œåˆ©ç”¨ runtime çš„ç»Ÿä¸€é”™è¯¯æ¨¡å‹ã€ç»Ÿä¸€æµæ¥å£ã€ç»Ÿä¸€ usage æ•°æ®ï¼Œæ„å»ºä¸€ä¸ª **å¯æ’æ‹”ã€å¯ç»„åˆã€å¯æ‰©å±•çš„å¤šæ¨¡å‹ç­–ç•¥ç³»ç»Ÿ**ã€‚

æˆ‘ä¼šä¿æŒä½ è¦æ±‚çš„é£æ ¼ï¼š**ä¸æŠ½è±¡ã€ä¸é£˜ã€å…¨éƒ¨å·¥ç¨‹çº§ã€å¯ç›´æ¥å†™ä»£ç çš„è®¾è®¡**ã€‚

---

# ğŸ§  ç¬¬äº”ä»½ï¼šå¤šæ¨¡å‹ç­–ç•¥å¼•æ“ï¼ˆStrategy Engineï¼‰  
### â€”â€” manifest-first + runtime-agnostic + provider-agnostic

ç­–ç•¥å¼•æ“æ˜¯åº”ç”¨å±‚ç»„ä»¶ï¼Œè´Ÿè´£ï¼š

- é€‰æ‹©æ¨¡å‹ï¼ˆmodel selectionï¼‰
- å†³å®šæ˜¯å¦ fallbackï¼ˆåŸºäºé”™è¯¯ç±»å‹ï¼‰
- å†³å®šæ˜¯å¦é‡è¯•ï¼ˆåŸºäºé”™è¯¯ç±»å‹ï¼‰
- å†³å®šæ¨¡å‹æ’åºï¼ˆåŸºäºæˆæœ¬ã€å»¶è¿Ÿã€èƒ½åŠ›ã€æˆåŠŸç‡ï¼‰
- å†³å®šæ˜¯å¦åˆ‡æ¢æ¨¡å‹ï¼ˆåŸºäº usage æˆ–é¢„ç®—ï¼‰
- å†³å®šæ˜¯å¦åŠ¨æ€è°ƒæ•´ç­–ç•¥ï¼ˆåœ¨çº¿å­¦ä¹ ï¼‰

runtime ä¸å‚ä¸ç­–ç•¥ï¼Œåªæä¾›ï¼š

- `call(model, operator, input) -> Result<ModelStream, ModelError>`
- usage æ•°æ®
- latency æ•°æ®
- é”™è¯¯åˆ†ç±»

ç­–ç•¥å¼•æ“æ˜¯ runtime çš„â€œä¸Šå±‚ orchestratorâ€ã€‚

---

# ğŸ§± 1. Strategy Engine çš„æ ¸å¿ƒæ¥å£ï¼ˆRustï¼‰

```rust
pub struct StrategyRequest {
    pub operator: String,
    pub input: String,
}

pub struct StrategyDecision {
    pub model: String,
}

pub trait StrategyEngine {
    fn decide(&self, req: &StrategyRequest) -> Vec<StrategyDecision>;
}
```

### è§£é‡Š  
- `decide()` è¿”å›ä¸€ä¸ª **æ¨¡å‹å€™é€‰åˆ—è¡¨**ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åºã€‚  
- runtime ä¼šæŒ‰é¡ºåºå°è¯•è¿™äº›æ¨¡å‹ï¼ˆç”±åº”ç”¨å±‚æ§åˆ¶ï¼‰ã€‚  
- runtime ä¸çŸ¥é“ç­–ç•¥æ˜¯ä»€ä¹ˆï¼ŒåªçŸ¥é“â€œè°ƒç”¨æ¨¡å‹â€ã€‚

---

# ğŸ§± 2. Strategy Engine çš„ç»„æˆæ¨¡å—

ç­–ç•¥å¼•æ“ç”±å¤šä¸ªå¯æ’æ‹”æ¨¡å—ç»„æˆï¼š

```
StrategyEngine
   â”œâ”€ CapabilityFilterï¼ˆèƒ½åŠ›è¿‡æ»¤ï¼‰
   â”œâ”€ CostRankerï¼ˆæŒ‰æˆæœ¬æ’åºï¼‰
   â”œâ”€ LatencyRankerï¼ˆæŒ‰å»¶è¿Ÿæ’åºï¼‰
   â”œâ”€ SuccessRateRankerï¼ˆæŒ‰æˆåŠŸç‡æ’åºï¼‰
   â”œâ”€ UserPreferenceï¼ˆç”¨æˆ·åå¥½ï¼‰
   â”œâ”€ Randomizationï¼ˆA/B æµ‹è¯•ï¼‰
   â””â”€ CompositeEngineï¼ˆç»„åˆå™¨ï¼‰
```

æ¯ä¸ªæ¨¡å—éƒ½å®ç°ï¼š

```rust
trait StrategyComponent {
    fn apply(&self, req: &StrategyRequest, candidates: Vec<String>) -> Vec<String>;
}
```

---

# ğŸ§± 3. CapabilityFilterï¼šæŒ‰èƒ½åŠ›è¿‡æ»¤ï¼ˆmanifest-firstï¼‰

manifest-first çš„ä¼˜åŠ¿æ˜¯ï¼š  
**æ¯ä¸ªæ¨¡å‹çš„ capabilities éƒ½åœ¨ manifest é‡Œã€‚**

```rust
pub struct CapabilityFilter<'a> {
    pub registry: &'a ModelRegistry,
}

impl<'a> StrategyComponent for CapabilityFilter<'a> {
    fn apply(&self, req: &StrategyRequest, _: Vec<String>) -> Vec<String> {
        self.registry
            .models()
            .iter()
            .filter(|(_, m)| m.capabilities.contains(&req.operator))
            .map(|(name, _)| name.clone())
            .collect()
    }
}
```

### æ•ˆæœ  
- è‡ªåŠ¨è¿‡æ»¤æ‰ä¸æ”¯æŒ generate/embed/vision/tools çš„æ¨¡å‹  
- ä¸éœ€è¦å†™æ­» provider  
- ä¸éœ€è¦å†™æ­»æ¨¡å‹  
- å®Œå…¨ manifest-first

---

# ğŸ§± 4. CostRankerï¼šæŒ‰æˆæœ¬æ’åºï¼ˆpricing-awareï¼‰

manifest-first çš„å¦ä¸€ä¸ªä¼˜åŠ¿æ˜¯ï¼š  
**æ¯ä¸ªæ¨¡å‹çš„ pricing éƒ½åœ¨ manifest é‡Œã€‚**

```rust
pub struct CostRanker<'a> {
    pub registry: &'a ModelRegistry,
}

impl<'a> StrategyComponent for CostRanker<'a> {
    fn apply(&self, req: &StrategyRequest, candidates: Vec<String>) -> Vec<String> {
        let mut list: Vec<_> = candidates
            .into_iter()
            .map(|model| {
                let m = self.registry.get(&model).unwrap();
                let price = m.pricing.as_ref().map(|p| p.input + p.output).unwrap_or(1.0);
                (model, price)
            })
            .collect();

        list.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());
        list.into_iter().map(|(m, _)| m).collect()
    }
}
```

### æ•ˆæœ  
- è‡ªåŠ¨é€‰æ‹©æœ€ä¾¿å®œçš„æ¨¡å‹  
- ä¸éœ€è¦å†™æ­»ä»·æ ¼  
- ä¸éœ€è¦å†™æ­» provider  
- å®Œå…¨ manifest-first

---

# ğŸ§± 5. LatencyRankerï¼šæŒ‰å»¶è¿Ÿæ’åºï¼ˆmetrics-awareï¼‰

runtime ä¼šè®°å½•æ¯ä¸ªæ¨¡å‹çš„å¹³å‡å»¶è¿Ÿï¼š

```rust
pub struct LatencyRanker<'a> {
    pub metrics: &'a MetricsStore,
}

impl<'a> StrategyComponent for LatencyRanker<'a> {
    fn apply(&self, _: &StrategyRequest, candidates: Vec<String>) -> Vec<String> {
        let mut list: Vec<_> = candidates
            .into_iter()
            .map(|model| {
                let latency = self.metrics.get_latency(&model).unwrap_or(1000.0);
                (model, latency)
            })
            .collect();

        list.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());
        list.into_iter().map(|(m, _)| m).collect()
    }
}
```

### æ•ˆæœ  
- è‡ªåŠ¨é€‰æ‹©æœ€å¿«çš„æ¨¡å‹  
- ä¸éœ€è¦å†™æ­» provider  
- ä¸éœ€è¦å†™æ­»æ¨¡å‹  
- å®Œå…¨ runtime-firstï¼ˆmetricsï¼‰+ manifest-firstï¼ˆcapabilitiesï¼‰

---

# ğŸ§± 6. SuccessRateRankerï¼šæŒ‰æˆåŠŸç‡æ’åºï¼ˆerror-awareï¼‰

runtime ä¼šè®°å½•æ¯ä¸ªæ¨¡å‹çš„æˆåŠŸç‡ï¼š

```rust
pub struct SuccessRateRanker<'a> {
    pub metrics: &'a MetricsStore,
}

impl<'a> StrategyComponent for SuccessRateRanker<'a> {
    fn apply(&self, _: &StrategyRequest, candidates: Vec<String>) -> Vec<String> {
        let mut list: Vec<_> = candidates
            .into_iter()
            .map(|model| {
                let rate = self.metrics.get_success_rate(&model).unwrap_or(0.5);
                (model, rate)
            })
            .collect();

        list.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap()); // success rate desc
        list.into_iter().map(|(m, _)| m).collect()
    }
}
```

### æ•ˆæœ  
- è‡ªåŠ¨é€‰æ‹©æˆåŠŸç‡é«˜çš„æ¨¡å‹  
- é€‚åˆç”Ÿäº§ç¯å¢ƒ  
- é€‚åˆ fallback ç­–ç•¥ï¼ˆä¼˜å…ˆå°è¯•æˆåŠŸç‡é«˜çš„ï¼‰

---

# ğŸ§± 7. CompositeEngineï¼šç»„åˆç­–ç•¥ï¼ˆå¯æ’æ‹”ï¼‰

```rust
pub struct CompositeEngine<'a> {
    pub components: Vec<Box<dyn StrategyComponent + 'a>>,
}

impl<'a> StrategyEngine for CompositeEngine<'a> {
    fn decide(&self, req: &StrategyRequest) -> Vec<StrategyDecision> {
        let mut candidates: Vec<String> = Vec::new();

        for comp in &self.components {
            candidates = comp.apply(req, candidates);
        }

        candidates
            .into_iter()
            .map(|m| StrategyDecision { model: m })
            .collect()
    }
}
```

### æ•ˆæœ  
ä½ å¯ä»¥ç»„åˆï¼š

```rust
let engine = CompositeEngine {
    components: vec![
        Box::new(CapabilityFilter { registry }),
        Box::new(CostRanker { registry }),
        Box::new(LatencyRanker { metrics }),
        Box::new(SuccessRateRanker { metrics }),
    ],
};
```

è¿™å°±å½¢æˆäº†ä¸€ä¸ªï¼š

- èƒ½åŠ›è¿‡æ»¤  
- æˆæœ¬æ’åº  
- å»¶è¿Ÿæ’åº  
- æˆåŠŸç‡æ’åº  

çš„ **å¤šæ¨¡å‹æ™ºèƒ½é€‰æ‹©å™¨**ã€‚

---

# ğŸ§± 8. åº”ç”¨å±‚å¦‚ä½•ä½¿ç”¨ StrategyEngine + Runtime

```rust
async fn smart_call(
    engine: &impl StrategyEngine,
    runtime: &Runtime,
    operator: &str,
    input: &str,
) -> Result<ModelStream, ModelError> {
    let req = StrategyRequest {
        operator: operator.into(),
        input: input.into(),
    };

    let decisions = engine.decide(&req);

    for d in decisions {
        match runtime.call(&d.model, operator, input).await {
            Ok(stream) => return Ok(stream),
            Err(err) => {
                if err.kind.is_client_bug() {
                    return Err(err);
                }
                continue;
            }
        }
    }

    Err(ModelError {
        kind: ErrorKind::Unknown,
        code: Some("NO_MODEL_SUCCEEDED".into()),
        message: "all models failed".into(),
        source: None,
    })
}
```

### æ•ˆæœ  
- runtime ä¸çŸ¥é“ç­–ç•¥  
- manifest ä¸çŸ¥é“ç­–ç•¥  
- ç­–ç•¥å¼•æ“ä¸åš HTTP  
- ä¸‰è€…å®Œå…¨è§£è€¦  
- ç»„åˆèµ·æ¥å°±æ˜¯ä¸€ä¸ªæ™ºèƒ½å¤šæ¨¡å‹ç³»ç»Ÿ

---

# ğŸ‰ æœ€ç»ˆæ•ˆæœï¼šä½ ç°åœ¨æ‹¥æœ‰ä¸€ä¸ªçœŸæ­£çš„å¤šæ¨¡å‹æ™ºèƒ½ç³»ç»Ÿ

é€šè¿‡è¿™ä»½è®¾è®¡ï¼Œä½ å·²ç»å…·å¤‡ï¼š

### âœ” manifest-firstï¼ˆæ¨¡å‹å£°æ˜ï¼‰  
### âœ” runtime-firstï¼ˆç»Ÿä¸€è°ƒç”¨ï¼‰  
### âœ” error-firstï¼ˆç»Ÿä¸€é”™è¯¯ï¼‰  
### âœ” strategy-firstï¼ˆæ™ºèƒ½é€‰æ‹©ï¼‰  

å¹¶ä¸”ï¼š

- ä¸å†™æ­» provider  
- ä¸å†™æ­»æ¨¡å‹  
- ä¸å†™æ­» fallback  
- ä¸å†™æ­»æ’åºé€»è¾‘  
- ä¸å†™æ­»æˆæœ¬/å»¶è¿Ÿ/æˆåŠŸç‡  
- ä¸å†™æ­»èƒ½åŠ›è¿‡æ»¤  

æ‰€æœ‰é€»è¾‘éƒ½å¯æ’æ‹”ã€å¯ç»„åˆã€å¯æ‰©å±•ã€‚

è¿™æ˜¯ä¸€ä¸ªçœŸæ­£çš„ **AI å¤šæ¨¡å‹æ“ä½œç³»ç»Ÿçº§æ¶æ„**ã€‚
